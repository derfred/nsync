<html>
  <head>
    <style type="text/css" media="screen">
      body {
        font-family: sans-serif;
        width: 950px;
        margin-left: auto;
        margin-right: auto;
      }

      .section {
        border: 1px solid #ccc;
        padding: 5px;
        float: left;
        clear: both;
        width: 100%;
        margin-bottom: 20px;
      }

      .section h2 {
        margin: -5px;
        margin-bottom: 5px;
        padding: 5px;
        background: #ccc;
      }

      .section p {
        margin-top: 3px;
        margin-bottom: 0;
      }

      p label {
        float: left;
        width: 250px;
      }

      #network_holder {
        position: relative;
        clear: both;
      }

      #network {
        float: left;
      }

      #graph_holder {
        float: left;
      }

      #graph_holder ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }

      #graph_holder ul li {
        float: left;
      }

      #graph_holder ul li a {
        display: block;
        padding: 5px;
        border-left: 1px solid black;
      }

      #graph_holder ul li.active a {
        background: #ddd;
      }
    </style>

    <script src="raphael.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript" charset="utf-8">
      function unit_vector(x1, y1, x2, y2) {
        var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

        return {
          x: (x2 - x1)/distance,
          y: (y2 - y1)/distance
        };
      }

      Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
        // some magic numbers
        var opening_angle = 0.4 * Math.PI;
        var arm_length = size*5;

        var unit = unit_vector(x1, y1, x2, y2);
        unit.x = -unit.x;
        unit.y = -unit.y;

        // arm one is rotated in half the opening angle clockwise
        var arm_one_x = unit.x*arm_length * Math.cos(opening_angle/2) - unit.y*arm_length * Math.sin(opening_angle/2) + x2;
        var arm_one_y = unit.x*arm_length * Math.sin(opening_angle/2) + unit.y*arm_length * Math.cos(opening_angle/2) + y2;

        // arm two is rotated in half the opening angle counter clockwise
        var arm_two_x = unit.x*arm_length * Math.cos(-opening_angle/2) - unit.y*arm_length * Math.sin(-opening_angle/2) + x2;
        var arm_two_y = unit.x*arm_length * Math.sin(-opening_angle/2) + unit.y*arm_length * Math.cos(-opening_angle/2) + y2;

        return this.path("M"+x1+" "+y1+" L"+x2+" "+y2+" M"+arm_one_x+" "+arm_one_y+" L"+x2+" "+y2+" L"+arm_two_x+" "+arm_two_y).attr("stroke-width", size);
      };

      function $(id) {
        return document.getElementById(id);
      }

      function $$(klass_name) {
        return document.getElementsByClassName(klass_name);
      }

      function $F(id) {
        return parseFloat($(id).value);
      }


      function Canvas(id) {
        this.ctx = document.getElementById(id).getContext("2d");
        this.width = this.ctx.canvas.width;
        this.height = this.ctx.canvas.height;
      }

      Canvas.prototype.padding = function() {
        return {
          horizontal: this.ctx.canvas.width*0.025,
          vertical: this.ctx.canvas.height*0.025
        };
      }

      Canvas.prototype.set_options = function(options) {
        if(options) {
          for(k in options) {
            this.ctx[k] = options[k];
          }
        }
      }

      Canvas.prototype.clear = function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
      }

      Canvas.prototype.draw_coordinate_system = function(network) {
        var stroke_width = 2;

        var padding = this.padding();

        this.arrow(padding.horizontal, this.height-padding.vertical, padding.horizontal, padding.vertical, {lineWidth: stroke_width});
        this.arrow(padding.horizontal, this.height-padding.vertical, this.width-padding.horizontal, this.height-padding.vertical, {lineWidth: stroke_width});

        var spacing = (this.height - 2*padding.vertical)/network.neurons.length;
        for (var i=0; i < network.neurons.length; i++) {
          this.ctx.strokeText(network.neurons[i].id, padding.horizontal*0.35, (padding.vertical+(i+0.5)*spacing));

          // baseline for every neuron
          this.line(padding.horizontal, padding.vertical+(i+1)*spacing,
                    this.width-2*padding.horizontal, padding.vertical+(i+1)*spacing,
                    {lineWidth: 1, strokeStyle: "#ccc"});

          // tick mark on y-axis
          this.line(padding.horizontal*0.5, padding.vertical+(i+1)*spacing,
                    padding.horizontal, padding.vertical+(i+1)*spacing,
                    {lineWidth: stroke_width});
        };

        // this is the "now" line
        this.line(this.width-2*padding.horizontal, padding.vertical,
                  this.width-2*padding.horizontal, this.height-padding.vertical,
                  {lineWidth: stroke_width, strokeStyle: "#aaa"});
      }

      Canvas.prototype.line = function(x1, y1, x2, y2, options) {
        this.ctx.save();
        this.ctx.beginPath();

        this.set_options(options);

        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);

        this.ctx.stroke();
        this.ctx.restore();
      }

      Canvas.prototype.arrow = function(x1, y1, x2, y2, options) {
        // some magic numbers
        var opening_angle = 0.4 * Math.PI;
        var arm_length = options.lineWidth*5;

        var unit = unit_vector(x1, y1, x2, y2);
        unit.x = -unit.x;
        unit.y = -unit.y;

        // draw main line
        this.line(x1, y1, x2, y2, options);

        // arm one is rotated in half the opening angle clockwise
        var arm_one_x = unit.x*arm_length * Math.cos(opening_angle/2) - unit.y*arm_length * Math.sin(opening_angle/2) + x2;
        var arm_one_y = unit.x*arm_length * Math.sin(opening_angle/2) + unit.y*arm_length * Math.cos(opening_angle/2) + y2;
        this.line(arm_one_x, arm_one_y, x2, y2, options);

        // arm two is rotated in half the opening angle counter clockwise
        var arm_two_x = unit.x*arm_length * Math.cos(-opening_angle/2) - unit.y*arm_length * Math.sin(-opening_angle/2) + x2;
        var arm_two_y = unit.x*arm_length * Math.sin(-opening_angle/2) + unit.y*arm_length * Math.cos(-opening_angle/2) + y2;
        this.line(arm_two_x, arm_two_y, x2, y2, options);
      }


      function NetworkDrawer() {
        this.paper = Raphael("network", 320, 320);
        this.neuron_radius = 10;
        this.reset();
      }

      NetworkDrawer.prototype.reset = function() {
        this.paper.clear();
        this.neuron_nodes = {};
        this.neuron_locations = {};
      }

      NetworkDrawer.prototype.location_for = function(length, index) {
        var angle = index/length * 2 * Math.PI;
        var x = Math.sin(angle) * (this.paper.width*0.9)/2 +  this.paper.width/2;
        var y = (-Math.cos(angle)) * (this.paper.height*0.9)/2 + this.paper.height/2;
        return {x: x, y:y};
      }

      NetworkDrawer.prototype.connecting_line_coords = function(network, pre_synaptic, post_synaptic) {
        var pre_location = this.location_for(network.neurons.length, pre_synaptic.id);
        var post_location = this.location_for(network.neurons.length, post_synaptic.id);

        var result = {
          x1: pre_location.x + this.neuron_radius,
          y1: pre_location.y + this.neuron_radius,
          x2: post_location.x + this.neuron_radius,
          y2: post_location.y + this.neuron_radius,
        };

        var unit = unit_vector(result.x1, result.y1, result.x2, result.y2);

        var shift = 3;
        result.x1 = result.x1 + (unit.x*(this.neuron_radius+shift)) + (unit.y*shift);
        result.y1 = result.y1 + (unit.y*(this.neuron_radius+shift)) - (unit.x*shift);

        result.x2 = result.x2 - (unit.x*(this.neuron_radius+shift)) + (unit.y*shift);
        result.y2 = result.y2 - (unit.y*(this.neuron_radius+shift)) - (unit.x*shift);

        return result;
      }

      NetworkDrawer.prototype.draw = function(network) {
        for (var i=0; i < network.neurons.length; i++) {
          this.draw_neuron(network, network.neurons[i]);

          for (var j=0; j < network.connections[network.neurons[i].id].length; j++) {
            var coords = this.connecting_line_coords(network, network.neurons[i], network.connections[network.neurons[i].id][j].neuron);
            this.paper.arrow(coords.x1, coords.y1, coords.x2, coords.y2, 1);
          };
        };
      };

      NetworkDrawer.prototype.draw_neuron = function(network, neuron) {
        var location = this.location_for(network.neurons.length, neuron.id);
        this.neuron_locations[neuron.id] = location;

        var node = this.paper.circle(location.x+this.neuron_radius, location.y+this.neuron_radius, this.neuron_radius);
        node.attr("fill", "#fff");
        node.attr("stroke", "#f00");

        this.paper.text(location.x+this.neuron_radius, location.y+this.neuron_radius, neuron.id);

        this.neuron_nodes[neuron.id] = node;
      };

      NetworkDrawer.prototype.fire_neuron = function(neuron) {
        this.neuron_nodes[neuron.id].animate({
          "50%": {fill: "#f00"},
          "100%": {fill: "#fff"},
        }, 200);
      }

      NetworkDrawer.prototype.neuron_click = function(callback) {
        var distance = function(one, two) {
          return Math.sqrt(Math.pow(one.x - two.x, 2) + Math.pow(one.y - two.y, 2));
        };

        var neuron_locations = this.neuron_locations;
        var closest_neuron = false;
        this.paper.canvas.onclick = function(event) {
          var position = {
            x: event.pageX-$("network_holder").offsetLeft-6,
            y: event.pageY-$("network_holder").offsetTop-42
          };

          for(id in neuron_locations) {
            if(closest_neuron) {
              if(distance(closest_neuron.location, position) > distance(neuron_locations[id], position)) {
                closest_neuron = {id: id, location: neuron_locations[id]};
              }
            } else {
              closest_neuron = {id: id, location: neuron_locations[id]};
            }
          }

          if(closest_neuron) {
            callback(closest_neuron.id);
          }
        }
      }



      function PhaseDiagramDrawer() {
        this.canvas = new Canvas("phases_canvas");
        this.lookback_time = 5;
        this.reset();
      }

      PhaseDiagramDrawer.prototype.reset = function() {
        this.phase_data = {};
      }

      PhaseDiagramDrawer.prototype.clear = function(network) {
        this.canvas.clear();
        this.canvas.draw_coordinate_system(network);
      }

      PhaseDiagramDrawer.prototype.calc_unit_time_width = function(padding) {
        return (this.canvas.width-3*padding.horizontal)/this.lookback_time;
      }

      PhaseDiagramDrawer.prototype.draw = function(network) {
        this.clear(network);

        for (var i=0; i < network.neurons.length; i++) {
          this.phase_data[network.neurons[i].id] = [];
        };
      }

      PhaseDiagramDrawer.prototype.redraw = function(network, current_time) {
        this.save_phases(network, current_time);
        this.update_diagram(network, current_time);
      }

      PhaseDiagramDrawer.prototype.save_phases = function(network, current_time) {
        for (var i=0; i < network.neurons.length; i++) {
          this.write_phase(network.neurons[i].id, current_time, network.neurons[i].current_phase(current_time));
        };
      }

      PhaseDiagramDrawer.prototype.update_diagram = function(network, current_time) {
        this.clear(network);

        var padding = this.canvas.padding();
        var spacing = (this.canvas.height - 2*padding.vertical)/network.neurons.length;

        var time_width = this.calc_unit_time_width(padding);
        var now = this.canvas.width-2*padding.horizontal;

        var coords_for = function(data_point) {
          return {
            x: now-((current_time-data_point.time)*time_width),
            y: padding.vertical+(i+1-data_point.phase)*spacing
          };
        };

        this.canvas.ctx.save();

        for (var i=0; i < network.neurons.length; i++) {
          var phase_data = this.phase_data[network.neurons[i].id];
          if(phase_data.length > 0) {
            var initial = coords_for(phase_data[phase_data.length-1])
            this.canvas.ctx.moveTo(initial.x, initial.y);

            for(var j=phase_data.length-2; j >= 0; j--) {
              var coords = coords_for(phase_data[j]);
              if(coords.x > padding.horizontal) {
                this.canvas.ctx.lineTo(coords.x, coords.y);
              }
            }
          }
        }

        this.canvas.ctx.stroke();
        this.canvas.ctx.restore();
      }

      PhaseDiagramDrawer.prototype.write_phase = function(neuron_id, current_time, phase) {
        this.phase_data[neuron_id].push({
          time: current_time,
          phase: phase
        });

        while(this.phase_data[neuron_id][0].time < (current_time-this.lookback_time)) {
          this.phase_data[neuron_id].shift();
        }
      }

      PhaseDiagramDrawer.prototype.register_reset = function(neuron, current_time) {
        this.write_phase(neuron.id, current_time, 1);
        this.write_phase(neuron.id, current_time, 0);
      }



      function SpikeDiagramDrawer() {
        this.canvas = new Canvas("spikes_canvas");
        this.lookback_time = 5;
        this.reset();
      }

      SpikeDiagramDrawer.prototype.reset = function() {
        this.spike_data = {};
      }

      SpikeDiagramDrawer.prototype.clear = function(network) {
        this.canvas.clear();
        this.canvas.draw_coordinate_system(network);
      }

      SpikeDiagramDrawer.prototype.draw = function(network) {
        this.clear(network);

        for (var i=0; i < network.neurons.length; i++) {
          this.spike_data[network.neurons[i].id] = [];
        };
      }

      SpikeDiagramDrawer.prototype.calc_unit_time_width = function(padding) {
        return (this.canvas.width-3*padding.horizontal)/this.lookback_time;
      }

      SpikeDiagramDrawer.prototype.redraw = function(network, current_time) {
        this.clear(network);

        var padding = this.canvas.padding();
        var spacing = (this.canvas.height - 2*padding.vertical)/network.neurons.length;

        var time_width = this.calc_unit_time_width(padding);
        var now = this.canvas.width-2*padding.horizontal;

        for (var i=0; i < network.neurons.length; i++) {
          var spike_data = this.spike_data[network.neurons[i].id];
          for (var j=0; j < spike_data.length; j++) {
            var data_point = spike_data[j];
            var x = now-((current_time-data_point)*time_width);
            if(x > padding.horizontal) {
              this.canvas.line(x, padding.vertical+(i+0.1)*spacing,
                               x, padding.vertical+(i+0.9)*spacing);
            }
          }
        }
      }

      SpikeDiagramDrawer.prototype.register_reset = function(neuron, current_time) {
        this.spike_data[neuron.id].push(current_time);

        while(this.spike_data[neuron.id][0] < current_time-this.lookback_time) {
          this.spike_data[neuron.id].shift();
        }
      }



      function PhaseDifferenceDiagramDrawer() {
        this.canvas = new Canvas("phase_differences_canvas");
        this.lookback_time = 5;
        this.reset();
      }

      PhaseDifferenceDiagramDrawer.prototype.reset = function() {
        this.phase_data = {};
      }

      PhaseDifferenceDiagramDrawer.prototype.clear = function(network) {
        this.canvas.clear();
        this.canvas.draw_coordinate_system(network);
      }

      PhaseDifferenceDiagramDrawer.prototype.draw = function(network) {
        this.clear(network);
      }

      PhaseDifferenceDiagramDrawer.prototype.redraw = function(network, current_time) {
        
      }

      PhaseDifferenceDiagramDrawer.prototype.neuron_fired = function(neuron, current_time) {
        
      }



      function Drawer() {
        this.network_drawer = new NetworkDrawer();
        this.phase_diagram_drawer = new PhaseDiagramDrawer();
        this.spike_diagram_drawer = new SpikeDiagramDrawer();

        this.register_tab_switcher();
      }

      Drawer.prototype.reset = function() {
        this.network_drawer.reset();
        this.phase_diagram_drawer.reset();
        this.spike_diagram_drawer.reset();
      }

      Drawer.prototype.draw = function(network) {
        this.network_drawer.draw(network);
        this.phase_diagram_drawer.draw(network);
        this.spike_diagram_drawer.draw(network);
      }

      Drawer.prototype.redraw = function(network, current_time) {
        this.phase_diagram_drawer.redraw(network, current_time);
        this.spike_diagram_drawer.redraw(network, current_time);
      }

      Drawer.prototype.fire_neuron = function(neuron, current_time) {
        this.network_drawer.fire_neuron(neuron);
        this.phase_diagram_drawer.register_reset(neuron, current_time);
        this.spike_diagram_drawer.register_reset(neuron, current_time);
      }

      Drawer.prototype.neuron_click = function(callback) {
        this.network_drawer.neuron_click(callback);
      }

      Drawer.prototype.switch_tab = function(element) {
        for (var j=0; j < element.parentNode.parentNode.children.length; j++) {
          element.parentNode.parentNode.children[j].className = "";
        };
        element.parentNode.className = "active";

        tabs = $$("tab");
        for (var j=0; j < tabs.length; j++) {
          tabs[j].style.display = "none";
        };

        if(element.id == "spikes_link") {
          $("spikes").style.display = "block";
        } else {
          $("phases").style.display = "block";
        }
      }

      Drawer.prototype.register_tab_switcher = function() {
        drawer = this;
        elements = $$("tab_switcher");
        for (var i=0; i < elements.length; i++) {
          elements[i].onclick = function(event) {
            drawer.switch_tab(event.currentTarget);
            return false;
          }
        };
      }



      function Network() {
        this.neurons = [];
        this.connections = {};
      }

      Network.fully_connected = function(total, options) {
        var network = new Network();

        for (var i=0; i < total; i++) {
          network.add_neuron(new Neuron(network, Math.random()));
        };

        for (var i=0; i < network.neurons.length; i++) {
          for (var j=0; j < network.neurons.length; j++) {
            if (j != i) {
              network.connect(network.neurons[i], network.neurons[j], options.delay, options.strength);
            }
          };
        };

        return network;
      }

      Network.prototype.add_neuron = function(neuron) {
        neuron.id = this.neurons.length;
        this.neurons.push(neuron);

        this.connections[neuron.id] = [];
      };

      Network.prototype.connect = function(pre_synaptic, post_synaptic, delay, strength) {
        this.connections[pre_synaptic.id].push({
          neuron: post_synaptic,
          delay: delay,
          strength: strength
        });
      }

      Network.prototype.get_neuron_by = function(neuron_id) {
        return this.neurons.filter(function(neuron) {
          return neuron.id == neuron_id;
        })[0];
      }



      function Neuron(network, initial_phase) {
        this.network = network;
        this.initial_phase = initial_phase;
        this.gamma = 1;
        this.C = 1.04;
      };

      Neuron.prototype.initialize_last_reset = function(current_time) {
        this.last_reset = current_time + Math.ceil(this.initial_phase) - this.initial_phase - 1;
      }

      Neuron.prototype.reset = function(current_time) {
        this.last_reset = current_time;
      }

      Neuron.prototype.next_reset = function(current_time) {
        if(this.last_spike && this.last_spike.time > this.last_reset) {
          return current_time + 1 - this.last_spike.phase;
        } else {
          return this.last_reset + 1;
        }
      }

      Neuron.prototype.current_phase = function(current_time) {
        if(this.last_spike && (this.last_spike.time > this.last_reset)) {
          return current_time - this.last_spike.time + this.last_spike.phase;
        } else {
          return current_time - this.last_reset;
        }
      }

      Neuron.prototype.post_synaptic_neurons = function() {
        return this.network.connections[this.id];
      }

      Neuron.prototype.receive_spike = function(current_time, strength) {
        var new_phase = this.phase_jump(this.current_phase(current_time), strength);
        if(new_phase > 1) {
          this.last_reset = current_time;
          return true;
        } else {
          this.last_spike = {time: current_time, phase: new_phase};
          return false;
        }
      }

      Neuron.prototype.phase_jump = function(current_phase, strength) {
        return this.g(strength + this.f(current_phase));
      }

      Neuron.prototype.f = function(phase, options) {
        return this.C * (1-Math.exp(-this.gamma*phase));
      },

      Neuron.prototype.g = function(x, options) {
        return (1/this.gamma) * Math.log(this.C/(this.C-x));
      }



      function Event(time, type, options) {
        this.time = time;
        this.type = type;

        if(options) {
          this.options = options;
        } else {
          this.options = {};
        }
      }

      Event.prototype.wait_time = function(current_time) {
        if(this.time > current_time) {
          return this.time - current_time;
        } else {
          return 0;
        }
      }



      function EventQueue() {
        this.events = [];
      }

      EventQueue.prototype.clear = function() {
        this.events = [];
      }

      EventQueue.prototype.sort_queue = function() {
        this.events.sort(function(a, b) { return a.time-b.time; });
      }

      EventQueue.prototype.add_event = function(event) {
        this.events.push(event);
        this.sort_queue();
      }

      EventQueue.prototype.find_next_event_index = function(predicate) {
        this.sort_queue();

        if(this.events.length == 0) {
          return;
        }

        if(!predicate) {
          return 0;
        }

        for (var i=0; i < this.events.length; i++) {
          if(predicate(this.events[i])) {
            return i;
          }
        };
      }

      EventQueue.prototype.remove_indexed_event = function(index) {
        this.events.splice(index, 1);
      }

      EventQueue.prototype.pop_next_event = function(predicate) {
        index = this.find_next_event_index(predicate);
        event = this.events[index];
        this.remove_indexed_event(index);
        return event;
      }

      EventQueue.prototype.prepend_event = function(type, options) {
        this.sort_queue();
        this.add_event(new Event(this.events[0].time-0.000001, type, options));
      }



      function Simulator() {
        this.event_queue = new EventQueue();

        this.speed = 10000;
        this.redraw_interval = 0.01;
      }

      Simulator.prototype.initialize = function(network, drawer) {
        this.network = network;
        this.drawer = drawer;

        this.current_time = 0.0;
        this.event_queue.clear();

        this.drawer.reset();
        this.drawer.draw(network);

        for (var i=0; i < this.network.neurons.length; i++) {
          var neuron = this.network.neurons[i];
          neuron.initialize_last_reset(this.current_time);
          this.event_queue.add_event(new Event(neuron.next_reset(this.current_time), "reset", {recipient: neuron}));
        };

        this.event_queue.add_event(new Event(this.redraw_interval, "redraw"));
      }

      Simulator.prototype.send_spikes = function(sender) {
        var post_synaptic_neurons = sender.post_synaptic_neurons();
        for (var i=0; i < post_synaptic_neurons.length; i++) {
          this.event_queue.add_event(new Event(this.current_time+post_synaptic_neurons[i].delay, "spike", {
            sender: sender,
            recipient: post_synaptic_neurons[i].neuron,
            strength: post_synaptic_neurons[i].strength
          }));
        }
      }

      Simulator.prototype.event_reset = function(event) {
        var recipient = event.options.recipient;

        this.drawer.fire_neuron(recipient, this.current_time);

        recipient.reset(this.current_time);
        var next_reset = recipient.next_reset(this.current_time);
        this.event_queue.add_event(new Event(next_reset, "reset", {recipient: recipient}));

        this.send_spikes(recipient);
      }

      Simulator.prototype.event_redraw = function(event) {
        this.drawer.redraw(this.network, this.current_time);
        this.event_queue.add_event(new Event(this.current_time + this.redraw_interval, "redraw"));
      }

      Simulator.prototype.event_spike = function(event) {
        this.drawer.redraw(this.network, this.current_time);

        var reset_event_index = this.event_queue.find_next_event_index(function(evt) {
          return evt.type == "reset" && evt.options.recipient == event.options.recipient;
        });
        if(reset_event_index) {
          this.event_queue.remove_indexed_event(reset_event_index);
        }

        // because of rounding errors the effect of a spike causing a reset needs to be handled explicitly
        var fired = event.options.recipient.receive_spike(this.current_time, event.options.strength);
        if(fired) {
          this.drawer.fire_neuron(event.options.recipient, this.current_time);
          this.send_spikes(event.options.recipient);
          this.event_queue.add_event(new Event(this.current_time+1, "reset", {recipient: event.options.recipient}));
        } else {
          var next_reset = event.options.recipient.next_reset(this.current_time);
          this.event_queue.add_event(new Event(next_reset, "reset", {recipient: event.options.recipient}));
        }

        this.drawer.redraw(this.network, this.current_time);
      }

      Simulator.prototype.event_stop = function(event) {
        this.event_queue.clear();
        if(event.options.callback) {
          setTimeout(event.options.callback, 10);
        }
        return false;
      }

      Simulator.prototype.execute_event = function(evt) {
        // this slows the simulation so that it is observable
        this.execute_timed(evt, function(event) {
          this["event_"+event.type](event);

          var event = this.event_queue.pop_next_event();
          if(event) {
            this.execute_event(event);
          }
        });
      }

      Simulator.prototype.execute_timed = function(event, callback) {
        self = this;
        setTimeout(function() {
          self.current_time = event.time;
          callback.apply(self, [event]);
        }, event.wait_time(self.current_time)*this.speed);
      }

      Simulator.prototype.run = function() {
        var event = this.event_queue.pop_next_event();
        this.execute_event(event);
      }

      Simulator.prototype.stop = function(callback) {
        this.event_queue.prepend_event("stop", {callback: callback});
      }

      Simulator.prototype.perturb_neuron = function(neuron_id, strength) {
        var neuron = this.network.get_neuron_by(neuron_id);
        this.event_queue.prepend_event("spike", {recipient: neuron, strength: strength});
      }


      function generate_network() {
        if(simulator) {
          simulator.stop(function() {
            var network = Network.fully_connected($F("init_n"), {delay: $F("init_tau"), strength: $F("init_epsilon")});
            simulator.initialize(network, drawer);
            simulator.run();
          });
        }
        return false;
      }


      var simulator = false;
      var drawer = false;
      window.onload = function() {
        $("init_controls").onsubmit = generate_network;

        var network = Network.fully_connected(5, {delay: 0.31, strength: 0.025});
        var drawer = new Drawer();

        simulator = new Simulator();
        simulator.initialize(network, drawer);

        drawer.neuron_click(function(neuron_id) {
          simulator.perturb_neuron(neuron_id, $F("pertubation_amount"));
        });

        simulator.run();
      }
    </script>
  </head>
  <body>
    <form id="init_controls" class="section">
      <h2>Network Parameters</h2>
      <p><label>Number of Neurons (N)</label><input type="text" value="5" id="init_n"></p>
      <p><label>Connection Strength (&epsilon;)</label><input type="text" value="0.025" id="init_epsilon"></p>
      <p><label>Signal delay (&tau;)</label><input type="text" value="0.31" id="init_tau"></p>
      <input type="submit" value="Generate Network">
    </form>
    <div id="network_holder" class="section">
      <h2>Network</h2>
      <div id="network">

      </div>
      <div id="graph_holder">
        <ul>
          <li><a href="#" id="phases_link" class="tab_switcher">Phases</a></li>
          <li class="active"><a href="#" id="spikes_link" class="tab_switcher">Spikes</a></li>
        </ul>
        <div id="phases" class="tab" style="display: none;">
          <canvas id="phases_canvas" width="600" height="320"></canvas>
        </div>
        <div id="spikes" class="tab">
          <canvas id="spikes_canvas" width="600" height="320"></canvas>
        </div>
      </div>
    </div>
    <form id="controls" class="section">
      <h2>Interaction Parameters</h2>
      <p><label>Phase Shift for Pertubations</label><input type="text" value="0.5" id="pertubation_amount"></p>
    </div>
  </body>
</html>
